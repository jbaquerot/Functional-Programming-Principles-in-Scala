package patmat

import org.scalatest.FunSuite
import common._
import patmat.Huffman._

object worksheet {
    val t1 = Fork(Leaf('a',2), Leaf('b',3), List('a','b'), 5)
                                                  //> t1  : patmat.Huffman.Fork = Fork(Leaf(a,2),Leaf(b,3),List(a, b),5)
    val t2 = Fork(Fork(Leaf('a',2), Leaf('b',3), List('a','b'), 5), Leaf('d',4), List('a','b','d'), 9)
                                                  //> t2  : patmat.Huffman.Fork = Fork(Fork(Leaf(a,2),Leaf(b,3),List(a, b),5),Leaf
                                                  //| (d,4),List(a, b, d),9)
		val trees = List(t1,t2)           //> trees  : List[patmat.Huffman.Fork] = List(Fork(Leaf(a,2),Leaf(b,3),List(a, b
                                                  //| ),5), Fork(Fork(Leaf(a,2),Leaf(b,3),List(a, b),5),Leaf(d,4),List(a, b, d),9)
                                                  //| )
    until(singleton,combine)(trees)               //> res0: patmat.Huffman.CodeTree = Fork(Fork(Leaf(a,2),Leaf(b,3),List(a, b),5),
                                                  //| Fork(Fork(Leaf(a,2),Leaf(b,3),List(a, b),5),Leaf(d,4),List(a, b, d),9),List(
                                                  //| a, b, a, b, d),14)
    createCodeTree(string2Chars("cabbaa"))        //> res1: patmat.Huffman.CodeTree = Fork(Fork(Leaf(c,1),Leaf(b,2),List(c, b),3),
                                                  //| Leaf(a,3),List(c, b, a),6)
 	  decode(createCodeTree(string2Chars("cabbaa")) , List(1,0,0,1,1,0,0,1,1))
                                                  //> res2: List[Char] = List(a, c, b, a)
 	  println(decodedSecret)                  //> List(e, f, s, t, d, r, s, l, a, e, i, h)
 	  
 	  encode(t1)("abab".toList)               //> res3: List[patmat.Huffman.Bit] = List(0, 1, 0, 1)
 
 	  decode(t1, encode(t1)("ab".toList))     //> res4: List[Char] = List(a)
 	  
 	  def encodeChar(tree:CodeTree, c:Char, accum:List[Bit]): List[Bit] = tree match{
 	  	case Leaf(c1,w) => if (c == c1) accum
 	  										 else List()
 	    case Fork(ltree, rtree, arrchars, w) => encodeChar(ltree, c, 0::accum) ::: encodeChar(rtree, c, 1::accum).reverse
 	  }                                       //> encodeChar: (tree: patmat.Huffman.CodeTree, c: Char, accum: List[patmat.Huff
                                                  //| man.Bit])List[patmat.Huffman.Bit]
    encodeChar(t1, 'b', List())                   //> res5: List[patmat.Huffman.Bit] = List(1)
    
    
    
    
    def decodeToChar(tree: CodeTree, bits: List[Bit]): Char = tree match{
    	case Leaf(c, w) => c
    	case Fork(ltree, rtree, arrchars, w) => bits match{
    		case List() => throw new Error("error")
    		case x::xs => if (x == 0) decodeToChar(ltree, xs)
    									else decodeToChar(rtree, xs)
    	}
    }                                             //> decodeToChar: (tree: patmat.Huffman.CodeTree, bits: List[patmat.Huffman.Bit
                                                  //| ])Char
    decodeToChar(t2,List(1))                      //> res6: Char = a
}